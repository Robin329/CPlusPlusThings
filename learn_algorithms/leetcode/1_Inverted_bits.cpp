//
// Created by renbin jiang on 2021/4/5.
//
//*************************************************
//题目：
//
//颠倒给定的 32 位无符号整数的二进制位。
//
//提示：
//
//请注意，在某些语言（如
// Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，
// 并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在
// Java 中， 编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2
// 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
//
//示例 1：
//
//输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000
// 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数
// 43261596， 因此返回 964176192，其二进制表示形式为
// 00111001011110000010100101000000。
//
//模拟：
//直接模拟，对新数进行左移，对每一位取&，拿出当前数，加到新数中，旧数右移。
#include <bitset>
#include <iostream>
using namespace std;

class Solution1 {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans = 0;
        for (int i = 0; i < 32; i++) {
            ans <<= 1;    // 左移一位作为高位
            ans += n & 1; //取出最后一位
            n >>= 1;      //依次取出最低位
        }
        return ans;
    }
};

// 分组交换法：
// 类似于归并排序，从32位一半位置进行前后置换，例如1011.....1100...会变成1100...1011....，其中省略部分与前面四位组成16位。
// 随后，再在前半16位与后半16位再进行折半交换，例如：前半16位：11000011
// 01101110，交换后应该位01101110 11000011，依次类推
// ，直到只剩下1位，要取出交换位的数，需要进行mask，例如：前半16位与中前8位与后8位交换，mask为ff00，32位便是ff00ff00表示32位数中每16位进行mask
// ，右移8位，交换即可。

class Solution2 {
public:
    uint32_t reverseBits(uint32_t n) {
        n = (n >> 16) | (n << 16);                             //低16位与高16位交换
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8); // 每16位中低8位和高8位交换
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4); // 每8位中低4位和高4位交换
        n = ((n & 0xcccccccc) >> 2) |
                ((n & 0x33333333) << 2); // 每4位中低2位和高2位交换 100 = c 0011=3
        n = ((n & 0xaaaaaaaa) >> 1) |
                ((n & 0x55555555) << 1); // 每2位中低1位和高1位交换 1010 = a 0101=5
        return n;
    }
};

int main(int argc, char **argv) {
    Solution1 solution1;
    Solution2 solution2;
    uint32_t a = 123423;
    cout << "a is   " << bitset<32>(a) << endl;
    cout << "ans is " << bitset<32>(solution1.reverseBits(a)) << endl;
    cout << "n is " << bitset<32>(solution2.reverseBits(a)) << endl;

    return 0;
}
